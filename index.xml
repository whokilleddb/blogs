<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>https://whokilleddb.github.io/blogs/</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 06 May 2023 17:11:28 +0530</lastBuildDate><atom:link href="https://whokilleddb.github.io/blogs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>UEFI Jungle</title>
      <link>https://whokilleddb.github.io/blogs/posts/uefi-jungle/</link>
      <pubDate>Sat, 06 May 2023 17:11:28 +0530</pubDate>
      
      <guid>https://whokilleddb.github.io/blogs/posts/uefi-jungle/</guid>
      <description>The UEFI Jungle While writing LazarusOS, I first came across UEFI from an implementation standpoint. I am pretty sure everyone has dealt with UEFI at some point, especially during booting up a new OS. In the good old days, we had the choice between Legacy BIOS and UEFI, and during some of my earlier iterations of the project, I did write some BIOS bootloaders in assembly, but transitioning to UEFI was a whole new game.</description>
    </item>
    
    <item>
      <title>Process Ghosting</title>
      <link>https://whokilleddb.github.io/blogs/posts/process-ghosting/</link>
      <pubDate>Wed, 05 Apr 2023 14:59:22 +0530</pubDate>
      
      <guid>https://whokilleddb.github.io/blogs/posts/process-ghosting/</guid>
      <description>Ghosted - A PoC on Process Ghosting &amp;ldquo;Ghost Processes Not People&amp;rdquo;
Introduction Process Ghosting is a technique of running payloads from an executable that has already been deleted. On Windows. it is possible to create a file, put it in a delete pending stage, write your payload to it, map it to an image section for it, close the file handle to delete the file, and then finally create a process from the mapped image section.</description>
    </item>
    
    <item>
      <title>A gentle guide to the land of .NET, CLR and ETW</title>
      <link>https://whokilleddb.github.io/blogs/posts/dotnet-clr-etw/</link>
      <pubDate>Wed, 25 Jan 2023 02:09:33 +0530</pubDate>
      
      <guid>https://whokilleddb.github.io/blogs/posts/dotnet-clr-etw/</guid>
      <description>Rant as an Introduction When initially getting into ETW and patching it, I was not prepared for what was coming. It was a deep rabbit hole of .NET, CLR and Windows Internals. Coming from a pure-C background(and a bit of Rust), this was a deep hole I was not prepared for at all. This blog is supposed to be more of a Journal than a tutorial as I try to figure things out!</description>
    </item>
    
    <item>
      <title>TryHackMe: Gallery</title>
      <link>https://whokilleddb.github.io/blogs/posts/thm_gallery/</link>
      <pubDate>Thu, 15 Sep 2022 01:50:35 +0530</pubDate>
      
      <guid>https://whokilleddb.github.io/blogs/posts/thm_gallery/</guid>
      <description>Introduction Challenge Name: Gallery
Difficulty: Easy
Nmap Enumeration Command :
$ sudo nmap -A -T4 --open -p- 10.10.17.83 -oN Gallery.nmap Output :
# Nmap 7.92 scan initiated Thu Sep 15 01:55:38 2022 as: nmap -A -T4 --open -p- -oN Gallery.nmap 10.10.17.83 Nmap scan report for 10.10.17.83 Host is up (0.19s latency). Not shown: 65516 closed tcp ports (reset), 17 filtered tcp ports (no-response) Some closed ports may be reported as filtered due to --defeat-rst-ratelimit PORT STATE SERVICE VERSION 80/tcp open http Apache httpd 2.</description>
    </item>
    
    <item>
      <title>TryHackMe: Dig Dug</title>
      <link>https://whokilleddb.github.io/blogs/posts/thm_dig_dug/</link>
      <pubDate>Thu, 15 Sep 2022 00:59:42 +0530</pubDate>
      
      <guid>https://whokilleddb.github.io/blogs/posts/thm_dig_dug/</guid>
      <description>Introduction Challenge Name: Dig Dug
Difficulty: (Super) Easy Nmap Scan TCP Scan Command :
$ sudo nmap -A -T4 --open -p- 10.10.237.159 -oN DigDug.nmap Output :
# Nmap 7.92 scan initiated Thu Sep 15 01:04:24 2022 as: nmap -A -T4 --open -p- -oN DigDug.nmap 10.10.237.159 Nmap scan report for 10.10.237.159 Host is up (0.16s latency). Not shown: 65275 closed tcp ports (reset), 259 filtered tcp ports (no-response) Some closed ports may be reported as filtered due to --defeat-rst-ratelimit PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.</description>
    </item>
    
    <item>
      <title>TryHackMe: Agentt</title>
      <link>https://whokilleddb.github.io/blogs/posts/thm_agentt/</link>
      <pubDate>Thu, 15 Sep 2022 00:22:07 +0530</pubDate>
      
      <guid>https://whokilleddb.github.io/blogs/posts/thm_agentt/</guid>
      <description>Introduction Challenge Name: Agnett
Difficulty: (Super) Easy
Nmap Scan Command :
$ sudo nmap -A -T4 --open -p- 10.10.121.103 -oN Agentt.nmap Output :
# Nmap 7.92 scan initiated Thu Sep 15 00:26:09 2022 as: nmap -A -T4 --open -p- -oN Agentt.nmap 10.10.121.103 Nmap scan report for 10.10.121.103 Host is up (0.17s latency). Not shown: 63135 closed tcp ports (reset), 2399 filtered tcp ports (no-response) Some closed ports may be reported as filtered due to --defeat-rst-ratelimit PORT STATE SERVICE VERSION 80/tcp open http PHP cli server 5.</description>
    </item>
    
    <item>
      <title>A Study In Obfuscation</title>
      <link>https://whokilleddb.github.io/blogs/posts/a_study_in_obfuscation/</link>
      <pubDate>Sat, 20 Aug 2022 15:18:00 +0530</pubDate>
      
      <guid>https://whokilleddb.github.io/blogs/posts/a_study_in_obfuscation/</guid>
      <description>Introduction In this blog series, we explore how to obfuscate a Metasploit payload to avoid detection by Antivirus Engines and shall try to go invisible. We would start from the ground up: Using a completely unobfuscated shellcode, and try to build upon it till we reach zero detections. All the associated code for this blog can be found in this Github repository.
We would employ known techniques and see how they affect detection rates uploading the compiled executable to AntiScan as it does not submit the samples to the vendors.</description>
    </item>
    
    <item>
      <title>CVE-2022-38258: DLink DIR 819 LFI And DoS</title>
      <link>https://whokilleddb.github.io/blogs/posts/dlink_dir-819_lfi_and_dos/</link>
      <pubDate>Sun, 31 Jul 2022 21:01:25 +0530</pubDate>
      
      <guid>https://whokilleddb.github.io/blogs/posts/dlink_dir-819_lfi_and_dos/</guid>
      <description>Introduction D-Link is one of the leading brands when it comes to manufacturing consumer routers. There&amp;rsquo;s a fair chance that you have a D-Link router back at home. The D-Link DIR 819 model is a very popular router.
In this blog post, I explain how I found a Local-File-Inclusion 0day, now designated as CVE-2022-38258, and escalated it to achieve a Denial-of-Service attack. Though the blog is written with respect to the DIR-819 model, it should be reproduceable on any router running the same firmware.</description>
    </item>
    
  </channel>
</rss>
